import logging
from argparse import Namespace
from dicom_validator.spec_reader.edition_reader import EditionReader
import numpy as np
from pathlib import Path
import pydicom
from dicom_validator.validator.dicom_file_validator import DicomFileValidator
import tempfile

from pydicom_generate.dcm import dicom_modalities, check_for_valid_modality

def generate_valid_template_dcm(modality: str) -> pydicom.Dataset:
    """
    Uses functionalized code from pydicom codify utility to generate a "valid" dcm object

    Parameters
    ----------
    modality: str one of CT, PT, MR
        The modality to generate, has to have a "pydicom_generated_xx_master.py" generated by codify

    Returns
    -------
    a "valid" pydicom "dcm" object produced from code, that can be updated by adding/replacing tags

    TODO: 2024-12 csk handle missing PixelData attribute? could test that size tags are valid
    """

    check_for_valid_modality(modality)

    ds = dicom_modalities[modality]['creator_function']()

    return ds

def generate_dcm_pydicom(modality: str,
                         pixel_data: np.ndarray=None,
                         tags=None,
                         origin = [0, 0, 0],
                         direction = [0, 0, 0, 0, 0, 0],
                         spacing = [1, 1, 1]):
    if tags is None:
        tags = {}

    slices = []

    # handle pixel_data
    if pixel_data is not None:
        slice_count = pixel_data.shape[2]
        for s in range(slice_count):
            slice_data = pixel_data[:, :, s]
            # first get a valid template ds
            ds = generate_valid_template_dcm(modality)
            ds.PixelData = slice_data.tobytes()
            ds.ImagePositionPatient = origin
            ds.ImageOrientationPatient = direction
            ds.SliceLocation = float(origin[2])
            ds.SliceThickness = float(spacing[2])
            ds.PixelSpacing = spacing[0:2]
            ds.Rows = pixel_data.shape[0]
            ds.Columns = pixel_data.shape[1]

            # replace tags:
            for tag, value in tags.items():
                # TODO: fix pydicom types!!
                ds[tag] = value
            slices.append(ds)


    return slices


def generate_dcm_dcmtk():
    pass

def validate_dcm(ds: pydicom.Dataset):
    """
    Validate that this is a usable pydicom Dataset, all required tags are present,
    size and position tags make sense, etc.

    Parameters
    ----------
    ds: a pydicom Dataset to be tested

    Returns
    -------
    list of issues found with the dataset, empty list if nothing found
    """

    # Create a temporary file
    temp_file = tempfile.NamedTemporaryFile(mode='w+b')
    pydicom.dcmwrite(f'{temp_file.file.name}.dcm', ds)

    # generate args
    args = Namespace(dicomfiles=[f'{temp_file.file.name}.dcm'],
                     standard_path=str(Path.home() / "dicom-validator"),
                     revision="current",
                     force_read=False,
                     recreate_json=False,
                     suppress_vr_warnings=False,
                     verbose=True)
    edition_reader = EditionReader(args.standard_path)
    base_path = edition_reader.get_revision(args.revision, args.recreate_json)
    json_path = Path(base_path, "json")
    dicom_info = EditionReader.load_dicom_info(json_path)
    log_level = logging.DEBUG if args.verbose else logging.INFO
    validator = DicomFileValidator(
        dicom_info, log_level, args.force_read, args.suppress_vr_warnings
    )
    error_nr = 0
    for dicom_path in args.dicomfiles:
        error_nr += sum(
            len(error) for error in list(validator.validate(dicom_path).values())
        )
    temp_file.close()
    return error_nr

